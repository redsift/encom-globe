#!/usr/bin/env node

var argv = require('minimist')(process.argv.slice(2)),
    PNG = require('pngjs').PNG,
    fs = require('fs'),
    Hexasphere = require('hexasphere.js');

var radius = 30;
var numDivisions = 35;
var scale = .45; 
var tiny = argv.t;
var map = argv.m;

if (argv.r) {
    radius = parseInt(argv.r);
}
if (argv.d) {
    numDivisions = parseInt(argv.d);
}
if (argv.s) {
    scale = parseFloat(argv.s);
}

var hexasphere = new Hexasphere(radius, numDivisions, scale);

var o = {tiles: []};

var latLonToXY = function(width, height, lat,lon){

    var x = Math.floor(width/2.0 + (width/360.0)*lon);
    var y = Math.floor((height/2.0 + (height/180.0)*lat));

    return {x: x, y:y};
};

var xyToIdx = function(x,y, width){
    return (width * y + x) << 2;
};

var rnd = function(num){
    return Math.round(num * 100) / 100;
};

// use a smaller representation of the tiles
function compress(t) {
    return t;
}

fs.createReadStream(map)
    .pipe(new PNG({
        filterType: 4
    }))
    .on('parsed', function() {
        for(var i = 0; i< hexasphere.tiles.length; i++){
            var count = 0;
            for(var j = 0; j< hexasphere.tiles[i].boundary.length; j++){
                var latLon = hexasphere.tiles[i].getLatLon(radius,j);
                var xy = latLonToXY(this.width, this.height, latLon.lat, latLon.lon);
                var idx = xyToIdx(xy.x, xy.y, this.width);
                count += 255 - this.data[idx];
            }

            latLon = hexasphere.tiles[i].getLatLon(radius);
            xy = latLonToXY(this.width, this.height, latLon.lat, latLon.lon);
            idx = xyToIdx(xy.x, xy.y, this.width);
            count += 255 - this.data[idx];

            var size = (count/(hexasphere.tiles[i].boundary.length + 1))/255;

            if (size > .1){
                var tile = {lat: rnd(latLon.lat), lon: rnd(latLon.lon), b: [] };
                var scale = size - Math.random() * .25;

                for (let j = 0; j< hexasphere.tiles[i].boundary.length; j++){
                    let newPoint = hexasphere.tiles[i].boundary[j].segment(hexasphere.tiles[i].centerPoint, size);
                    tile.b.push({
                        x: rnd(newPoint.x),
                        y: rnd(newPoint.y),
                        z: rnd(newPoint.z)
                    });
                }

                o.tiles.push(tiny ? compress(tile) : tile);
            }
        }
        let json = null;
        if (tiny) {
            json = JSON.stringify(o);
        } else {
            json = JSON.stringify(o, null, 4);
        }
        const output = "export const tiles = " + json + ";";

        if (argv.o) {
            fs.writeFile(argv.o, output);
        } else {
            console.log(output);
        }

    });


